var searchIndex = {};
searchIndex['rand'] = {"items":[[0,"","rand","Interface to random number generators in Rust."],[3,"Generator","","Iterator which will generate a stream of random items."],[3,"AsciiGenerator","","Iterator which will continuously generate random ascii characters."],[3,"XorShiftRng","","An Xorshift[1] random number\ngenerator."],[3,"Open01","","A wrapper for generating floating point numbers uniformly in the\nopen interval `(0,1)` (not including either endpoint)."],[3,"Closed01","","A wrapper for generating floating point numbers uniformly in the\nclosed interval `[0,1]` (including both endpoints)."],[0,"distributions","","Sampling from random distributions."],[3,"RandSample","rand::distributions","A wrapper for generating types that implement `Rand` via the\n`Sample` & `IndependentSample` traits."],[3,"Weighted","","A value with a particular weight for use with `WeightedChoice`."],[12,"weight","","The numerical weight of this item",0],[12,"item","","The actual item which is being weighted",0],[3,"WeightedChoice","","A distribution that selects from a finite collection of weighted items."],[0,"range","","Generating numbers between two others."],[3,"Range","rand::distributions::range","Sample values uniformly between two bounds."],[8,"SampleRange","","The helper trait for types that have a sensible way to sample\nuniformly between two values. This should not be used directly,\nand is only to facilitate `Range`."],[10,"construct_range","","Construct the `Range` object that `sample_range`\nrequires. This should not ever be called directly, only via\n`Range::new`, which will check that `low < high`, so this\nfunction doesn't have to repeat the check.",1],[10,"sample_range","","Sample a value from the given `Range` with the given `Rng` as\na source of randomness.",1],[11,"new","","Create a new `Range` instance that samples uniformly from\n`[low, high)`. Panics if `low >= high`.",2],[11,"sample","","",2],[11,"ind_sample","","",2],[0,"gamma","rand::distributions","The Gamma and derived distributions."],[3,"Gamma","rand::distributions::gamma","The Gamma distribution `Gamma(shape, scale)` distribution."],[3,"ChiSquared","","The chi-squared distribution `χ²(k)`, where `k` is the degrees of\nfreedom."],[3,"FisherF","","The Fisher F distribution `F(m, n)`."],[3,"StudentT","","The Student t distribution, `t(nu)`, where `nu` is the degrees of\nfreedom."],[11,"new","","Construct an object representing the `Gamma(shape, scale)`\ndistribution.",3],[11,"sample","","",3],[11,"ind_sample","","",3],[11,"new","","Create a new chi-squared distribution with degrees-of-freedom\n`k`. Panics if `k < 0`.",4],[11,"sample","","",4],[11,"ind_sample","","",4],[11,"new","","Create a new `FisherF` distribution, with the given\nparameter. Panics if either `m` or `n` are not positive.",5],[11,"sample","","",5],[11,"ind_sample","","",5],[11,"new","","Create a new Student t distribution with `n` degrees of\nfreedom. Panics if `n <= 0`.",6],[11,"sample","","",6],[11,"ind_sample","","",6],[0,"normal","rand::distributions","The normal and derived distributions."],[3,"StandardNormal","rand::distributions::normal","A wrapper around an `f64` to generate N(0, 1) random numbers\n(a.k.a.  a standard normal, or Gaussian)."],[3,"Normal","","The normal distribution `N(mean, std_dev**2)`."],[3,"LogNormal","","The log-normal distribution `ln N(mean, std_dev**2)`."],[11,"rand","","",7],[11,"new","","Construct a new `Normal` distribution with the given mean and\nstandard deviation.",8],[11,"sample","","",8],[11,"ind_sample","","",8],[11,"new","","Construct a new `LogNormal` distribution with the given mean\nand standard deviation.",9],[11,"sample","","",9],[11,"ind_sample","","",9],[0,"exponential","rand::distributions","The exponential distribution."],[3,"Exp1","rand::distributions::exponential","A wrapper around an `f64` to generate Exp(1) random numbers."],[3,"Exp","","The exponential distribution `Exp(lambda)`."],[11,"rand","","",10],[11,"new","","Construct a new `Exp` with the given shape parameter\n`lambda`. Panics if `lambda <= 0`.",11],[11,"sample","","",11],[11,"ind_sample","","",11],[8,"Sample","rand::distributions","Types that can be used to create a random instance of `Support`."],[10,"sample","","Generate a random value of `Support`, using `rng` as the\nsource of randomness.",12],[8,"IndependentSample","","`Sample`s that do not require keeping track of state."],[10,"ind_sample","","Generate a random value.",13],[11,"sample","","",14],[11,"ind_sample","","",14],[11,"new","","Create a new `WeightedChoice`.",15],[11,"sample","","",15],[11,"ind_sample","","",15],[0,"isaac","rand","The ISAAC random number generator."],[3,"IsaacRng","rand::isaac","A random number generator that uses the ISAAC algorithm[1]."],[3,"Isaac64Rng","","A random number generator that uses ISAAC-64[1], the 64-bit\nvariant of the ISAAC algorithm."],[11,"new_unseeded","","Create an ISAAC random number generator using the default\nfixed seed.",16],[11,"clone","","",16],[11,"next_u32","","",16],[11,"reseed","","",16],[11,"from_seed","","Create an ISAAC random number generator with a seed. This can\nbe any length, although the maximum number of elements used is\n256 and any more will be silently ignored. A generator\nconstructed with a given seed will generate the same sequence\nof values as all other generators constructed with that seed.",16],[11,"rand","","",16],[11,"new_unseeded","","Create a 64-bit ISAAC random number generator using the\ndefault fixed seed.",17],[11,"clone","","",17],[11,"next_u32","","",17],[11,"next_u64","","",17],[11,"reseed","","",17],[11,"from_seed","","Create an ISAAC random number generator with a seed. This can\nbe any length, although the maximum number of elements used is\n256 and any more will be silently ignored. A generator\nconstructed with a given seed will generate the same sequence\nof values as all other generators constructed with that seed.",17],[11,"rand","","",17],[0,"chacha","rand","The ChaCha random number generator."],[3,"ChaChaRng","rand::chacha","A random number generator that uses the ChaCha20 algorithm [1]."],[11,"clone","","",18],[11,"new_unseeded","","Create an ChaCha random number generator using the default\nfixed key of 8 zero words.",18],[11,"set_counter","","Sets the internal 128-bit ChaCha counter to\na user-provided value. This permits jumping\narbitrarily ahead (or backwards) in the pseudorandom stream.",18],[11,"next_u32","","",18],[11,"reseed","","",18],[11,"from_seed","","Create a ChaCha generator from a seed,\nobtained from a variable-length u32 array.\nOnly up to 8 words are used; if less than 8\nwords are used, the remaining are set to zero.",18],[11,"rand","","",18],[0,"reseeding","rand","A wrapper around another RNG that reseeds it after it\ngenerates a certain number of random bytes."],[3,"ReseedingRng","rand::reseeding","A wrapper around any RNG which reseeds the underlying RNG after it\nhas generated a certain number of random bytes."],[12,"reseeder","","Controls the behaviour when reseeding the RNG.",19],[3,"ReseedWithDefault","","Reseed an RNG using a `Default` instance. This reseeds by\nreplacing the RNG with the result of a `Default::default` call."],[8,"Reseeder","","Something that can be used to reseed an RNG via `ReseedingRng`."],[10,"reseed","","Reseed the given RNG.",20],[11,"new","","Create a new `ReseedingRng` with the given parameters.",19],[11,"reseed_if_necessary","","Reseed the internal RNG if the number of bytes that have been\ngenerated exceed the threshold.",19],[11,"next_u32","","",19],[11,"next_u64","","",19],[11,"fill_bytes","","",19],[11,"reseed","","",19],[11,"from_seed","","Create a new `ReseedingRng` from the given reseeder and\nseed. This uses a default value for `generation_threshold`.",19],[11,"reseed","","",21],[11,"default","","",21],[11,"rand","rand","",22],[11,"rand","","",23],[11,"rand","","",22],[11,"rand","","",23],[11,"rand","core::option","",24],[11,"is_some","","Returns `true` if the option is a `Some` value",24],[11,"is_none","","Returns `true` if the option is a `None` value",24],[11,"as_ref","","Convert from `Option<T>` to `Option<&T>`",24],[11,"as_mut","","Convert from `Option<T>` to `Option<&mut T>`",24],[11,"as_mut_slice","","Convert from `Option<T>` to `&mut [T]` (without copying)",24],[11,"expect","","Unwraps an option, yielding the content of a `Some`",24],[11,"unwrap","","Returns the inner `T` of a `Some(T)`.",24],[11,"unwrap_or","","Returns the contained value or a default.",24],[11,"unwrap_or_else","","Returns the contained value or computes it from a closure.",24],[11,"map","","Maps an `Option<T>` to `Option<U>` by applying a function to a contained value",24],[11,"map_or","","Applies a function to the contained value or returns a default.",24],[11,"map_or_else","","Applies a function to the contained value or computes a default.",24],[11,"ok_or","","Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to\n`Ok(v)` and `None` to `Err(err)`.",24],[11,"ok_or_else","","Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to\n`Ok(v)` and `None` to `Err(err())`.",24],[11,"iter","","Returns an iterator over the possibly contained value.",24],[11,"iter_mut","","Returns a mutable iterator over the possibly contained value.",24],[11,"into_iter","","Returns a consuming iterator over the possibly contained value.",24],[11,"and","","Returns `None` if the option is `None`, otherwise returns `optb`.",24],[11,"and_then","","Returns `None` if the option is `None`, otherwise calls `f` with the\nwrapped value and returns the result.",24],[11,"or","","Returns the option if it contains a value, otherwise returns `optb`.",24],[11,"or_else","","Returns the option if it contains a value, otherwise calls `f` and\nreturns the result.",24],[11,"take","","Takes the value out of the option, leaving a `None` in its place.",24],[11,"cloned","","Maps an Option<D> to an Option<T> by dereffing and cloning the contents of the Option.\nUseful for converting an Option<&T> to an Option<T>.",24],[11,"unwrap_or_default","","Returns the contained value or a default",24],[11,"fmt","core::num","",25],[11,"eq","","",25],[11,"ne","","",25],[11,"ne","","",25],[11,"hash","core::nonzero","",26],[11,"fmt","","",26],[11,"partial_cmp","","",26],[11,"lt","","",26],[11,"le","","",26],[11,"gt","","",26],[11,"ge","","",26],[11,"lt","","",26],[11,"le","","",26],[11,"gt","","",26],[11,"ge","","",26],[11,"cmp","","",26],[11,"eq","","",26],[11,"ne","","",26],[11,"ne","","",26],[11,"assert_receiver_is_total_eq","","",26],[11,"clone","","",26],[11,"clone_from","","",26],[11,"new","","Create an instance of NonZero with the provided value.\nYou must indeed ensure that the value is actually \"non-zero\".",26],[11,"deref","","",26],[11,"null","core::ptr","Returns a null Unique.",27],[11,"offset","","Return an (unsafe) pointer into the memory owned by `self`.",27],[11,"cmp","core::marker","",28],[11,"partial_cmp","","",28],[11,"lt","","",28],[11,"le","","",28],[11,"gt","","",28],[11,"ge","","",28],[11,"lt","","",28],[11,"le","","",28],[11,"gt","","",28],[11,"ge","","",28],[11,"assert_receiver_is_total_eq","","",28],[11,"eq","","",28],[11,"ne","","",28],[11,"ne","","",28],[11,"clone","","",28],[11,"clone_from","","",28],[11,"cmp","","",29],[11,"partial_cmp","","",29],[11,"lt","","",29],[11,"le","","",29],[11,"gt","","",29],[11,"ge","","",29],[11,"lt","","",29],[11,"le","","",29],[11,"gt","","",29],[11,"ge","","",29],[11,"assert_receiver_is_total_eq","","",29],[11,"eq","","",29],[11,"ne","","",29],[11,"ne","","",29],[11,"clone","","",29],[11,"clone_from","","",29],[11,"cmp","","",30],[11,"partial_cmp","","",30],[11,"lt","","",30],[11,"le","","",30],[11,"gt","","",30],[11,"ge","","",30],[11,"lt","","",30],[11,"le","","",30],[11,"gt","","",30],[11,"ge","","",30],[11,"assert_receiver_is_total_eq","","",30],[11,"eq","","",30],[11,"ne","","",30],[11,"ne","","",30],[11,"clone","","",30],[11,"clone_from","","",30],[11,"cmp","","",31],[11,"partial_cmp","","",31],[11,"lt","","",31],[11,"le","","",31],[11,"gt","","",31],[11,"ge","","",31],[11,"lt","","",31],[11,"le","","",31],[11,"gt","","",31],[11,"ge","","",31],[11,"assert_receiver_is_total_eq","","",31],[11,"eq","","",31],[11,"ne","","",31],[11,"ne","","",31],[11,"clone","","",31],[11,"clone_from","","",31],[11,"cmp","","",32],[11,"partial_cmp","","",32],[11,"lt","","",32],[11,"le","","",32],[11,"gt","","",32],[11,"ge","","",32],[11,"lt","","",32],[11,"le","","",32],[11,"gt","","",32],[11,"ge","","",32],[11,"assert_receiver_is_total_eq","","",32],[11,"eq","","",32],[11,"ne","","",32],[11,"ne","","",32],[11,"clone","","",32],[11,"clone_from","","",32],[11,"cmp","","",33],[11,"partial_cmp","","",33],[11,"lt","","",33],[11,"le","","",33],[11,"gt","","",33],[11,"ge","","",33],[11,"lt","","",33],[11,"le","","",33],[11,"gt","","",33],[11,"ge","","",33],[11,"assert_receiver_is_total_eq","","",33],[11,"eq","","",33],[11,"ne","","",33],[11,"ne","","",33],[11,"clone","","",33],[11,"clone_from","","",33],[11,"cmp","","",34],[11,"partial_cmp","","",34],[11,"lt","","",34],[11,"le","","",34],[11,"gt","","",34],[11,"ge","","",34],[11,"lt","","",34],[11,"le","","",34],[11,"gt","","",34],[11,"ge","","",34],[11,"assert_receiver_is_total_eq","","",34],[11,"eq","","",34],[11,"ne","","",34],[11,"ne","","",34],[11,"clone","","",34],[11,"clone_from","","",34],[11,"cmp","","",35],[11,"partial_cmp","","",35],[11,"lt","","",35],[11,"le","","",35],[11,"gt","","",35],[11,"ge","","",35],[11,"lt","","",35],[11,"le","","",35],[11,"gt","","",35],[11,"ge","","",35],[11,"assert_receiver_is_total_eq","","",35],[11,"eq","","",35],[11,"ne","","",35],[11,"ne","","",35],[11,"clone","","",35],[11,"clone_from","","",35],[11,"assert_receiver_is_total_eq","core::ops","",36],[11,"eq","","",36],[11,"ne","","",36],[11,"ne","","",36],[11,"clone","","",36],[11,"clone_from","","",36],[11,"fmt","","",36],[11,"assert_receiver_is_total_eq","","",37],[11,"eq","","",37],[11,"ne","","",37],[11,"ne","","",37],[11,"clone","","",37],[11,"clone_from","","",37],[11,"fmt","","",37],[11,"assert_receiver_is_total_eq","","",38],[11,"eq","","",38],[11,"ne","","",38],[11,"ne","","",38],[11,"clone","","",38],[11,"clone_from","","",38],[11,"fmt","","",38],[11,"assert_receiver_is_total_eq","","",39],[11,"eq","","",39],[11,"ne","","",39],[11,"ne","","",39],[11,"clone","","",39],[11,"clone_from","","",39],[11,"fmt","","",39],[11,"fmt","core::cmp","",40],[11,"eq","","",40],[11,"ne","","",40],[11,"ne","","",40],[11,"clone","","",40],[11,"clone_from","","",40],[11,"reverse","","Reverse the `Ordering`, so that `Less` becomes `Greater` and\nvice versa.",40],[11,"assert_receiver_is_total_eq","","",40],[11,"cmp","","",40],[11,"partial_cmp","","",40],[11,"lt","","",40],[11,"le","","",40],[11,"gt","","",40],[11,"ge","","",40],[11,"is","rand::std","Returns true if the boxed type is the same as `T`",41],[11,"downcast_ref","","Returns some reference to the boxed value if it is of type `T`, or\n`None` if it isn't.",41],[11,"downcast_mut","","Returns some mutable reference to the boxed value if it is of type `T`, or\n`None` if it isn't.",41],[11,"hash","core::any","",42],[11,"fmt","","",42],[11,"assert_receiver_is_total_eq","","",42],[11,"eq","","",42],[11,"ne","","",42],[11,"ne","","",42],[11,"clone","","",42],[11,"clone_from","","",42],[11,"of","","Returns the `TypeId` of the type this generic function has been\ninstantiated with",42],[11,"new","core::atomic","Creates a new `AtomicBool`.",43],[11,"load","","Loads a value from the bool.",43],[11,"store","","Stores a value into the bool.",43],[11,"swap","","Stores a value into the bool, returning the old value.",43],[11,"compare_and_swap","","Stores a value into the bool if the current value is the same as the expected value.",43],[11,"fetch_and","","Logical \"and\" with a boolean value.",43],[11,"fetch_nand","","Logical \"nand\" with a boolean value.",43],[11,"fetch_or","","Logical \"or\" with a boolean value.",43],[11,"fetch_xor","","Logical \"xor\" with a boolean value.",43],[11,"new","","Creates a new `AtomicIsize`.",44],[11,"load","","Loads a value from the isize.",44],[11,"store","","Stores a value into the isize.",44],[11,"swap","","Stores a value into the isize, returning the old value.",44],[11,"compare_and_swap","","Stores a value into the isize if the current value is the same as the expected value.",44],[11,"fetch_add","","Add an isize to the current value, returning the previous value.",44],[11,"fetch_sub","","Subtract an isize from the current value, returning the previous value.",44],[11,"fetch_and","","Bitwise and with the current isize, returning the previous value.",44],[11,"fetch_or","","Bitwise or with the current isize, returning the previous value.",44],[11,"fetch_xor","","Bitwise xor with the current isize, returning the previous value.",44],[11,"new","","Creates a new `AtomicUsize`.",45],[11,"load","","Loads a value from the usize.",45],[11,"store","","Stores a value into the usize.",45],[11,"swap","","Stores a value into the usize, returning the old value.",45],[11,"compare_and_swap","","Stores a value into the usize if the current value is the same as the expected value.",45],[11,"fetch_add","","Add to the current usize, returning the previous value.",45],[11,"fetch_sub","","Subtract from the current usize, returning the previous value.",45],[11,"fetch_and","","Bitwise and with the current usize, returning the previous value.",45],[11,"fetch_or","","Bitwise or with the current usize, returning the previous value.",45],[11,"fetch_xor","","Bitwise xor with the current usize, returning the previous value.",45],[11,"new","","Creates a new `AtomicPtr`.",46],[11,"load","","Loads a value from the pointer.",46],[11,"store","","Stores a value into the pointer.",46],[11,"swap","","Stores a value into the pointer, returning the old value.",46],[11,"compare_and_swap","","Stores a value into the pointer if the current value is the same as the expected value.",46],[11,"new","","",47],[11,"load","","",47],[11,"store","","",47],[11,"swap","","",47],[11,"compare_and_swap","","",47],[11,"fetch_add","","",47],[11,"fetch_sub","","",47],[11,"fetch_and","","",47],[11,"fetch_or","","",47],[11,"fetch_xor","","",47],[11,"new","","",48],[11,"load","","",48],[11,"store","","",48],[11,"swap","","",48],[11,"compare_and_swap","","",48],[11,"fetch_add","","",48],[11,"fetch_sub","","",48],[11,"fetch_and","","",48],[11,"fetch_or","","",48],[11,"fetch_xor","","",48],[11,"into_cow","core::borrow","",49],[11,"clone","","",49],[11,"clone_from","","",49],[11,"to_mut","","Acquire a mutable reference to the owned form of the data.",49],[11,"into_owned","","Extract the owned data.",49],[11,"is_borrowed","","Returns true if this `Cow` wraps a borrowed value",49],[11,"is_owned","","Returns true if this `Cow` wraps an owned value",49],[11,"deref","","",49],[11,"assert_receiver_is_total_eq","","",49],[11,"cmp","","",49],[11,"eq","","",49],[11,"ne","","",49],[11,"partial_cmp","","",49],[11,"lt","","",49],[11,"le","","",49],[11,"gt","","",49],[11,"ge","","",49],[11,"fmt","","",49],[11,"fmt","","",49],[11,"new","core::cell","Creates a new `Cell` containing the given value.",50],[11,"get","","Returns a copy of the contained value.",50],[11,"set","","Sets the contained value.",50],[11,"as_unsafe_cell","","Get a reference to the underlying `UnsafeCell`.",50],[11,"clone","","",50],[11,"clone_from","","",50],[11,"default","","",50],[11,"eq","","",50],[11,"ne","","",50],[11,"new","","Creates a new `RefCell` containing `value`.",51],[11,"into_inner","","Consumes the `RefCell`, returning the wrapped value.",51],[11,"try_borrow","","Attempts to immutably borrow the wrapped value.",51],[11,"borrow","","Immutably borrows the wrapped value.",51],[11,"try_borrow_mut","","Mutably borrows the wrapped value.",51],[11,"borrow_mut","","Mutably borrows the wrapped value.",51],[11,"as_unsafe_cell","","Get a reference to the underlying `UnsafeCell`.",51],[11,"clone","","",51],[11,"clone_from","","",51],[11,"default","","",51],[11,"eq","","",51],[11,"ne","","",51],[11,"drop","","",52],[11,"clone","","",52],[11,"clone_from","","",52],[11,"deref","","",53],[11,"drop","","",54],[11,"deref","","",55],[11,"deref_mut","","",55],[11,"new","","Construct a new instance of `UnsafeCell` which will wrap the specified\nvalue.",56],[11,"get","","Gets a mutable pointer to the wrapped value.",56],[11,"into_inner","","Unwraps the value",56],[11,"clone","core::char","",57],[11,"clone_from","","",57],[11,"clone","","",58],[11,"clone_from","","",58],[11,"next","","",57],[11,"size_hint","","",57],[11,"clone","","",59],[11,"clone_from","","",59],[11,"clone","","",60],[11,"clone_from","","",60],[11,"next","","",59],[11,"size_hint","","",59],[11,"drop","core::finally","",61],[11,"len","core::iter","",62],[11,"len","","",63],[11,"len","","",64],[11,"len","","",65],[11,"len","","",66],[11,"clone","","",64],[11,"clone_from","","",64],[11,"next","","",64],[11,"size_hint","","",64],[11,"size_hint","","",64],[11,"next_back","","",64],[11,"indexable","","",64],[11,"idx","","",64],[11,"next","","",67],[11,"size_hint","","",67],[11,"size_hint","","",67],[11,"next_back","","",67],[11,"len","","",67],[11,"fmt","","",68],[11,"eq","","",68],[11,"ne","","",68],[11,"ne","","",68],[11,"clone","","",68],[11,"clone_from","","",68],[11,"into_option","","`into_option` creates an `Option` of type `(T,T)`. The returned `Option` has variant\n`None` if and only if the `MinMaxResult` has variant `NoElements`. Otherwise variant\n`Some(x,y)` is returned where `x <= y`. If `MinMaxResult` has variant `OneElement(x)`,\nperforming this operation will make one clone of `x`.",68],[11,"clone","","",69],[11,"clone_from","","",69],[11,"next","","",69],[11,"size_hint","","",69],[11,"size_hint","","",69],[11,"next_back","","",69],[11,"len","","",69],[11,"clone","","",70],[11,"clone_from","","",70],[11,"next","","",70],[11,"size_hint","","",70],[11,"size_hint","","",70],[11,"indexable","","",70],[11,"idx","","",70],[11,"clone","","",71],[11,"clone_from","","",71],[11,"next","","",71],[11,"size_hint","","",71],[11,"size_hint","","",71],[11,"next_back","","",71],[11,"indexable","","",71],[11,"idx","","",71],[11,"clone","","",66],[11,"clone_from","","",66],[11,"next","","",66],[11,"size_hint","","",66],[11,"size_hint","","",66],[11,"next_back","","",66],[11,"indexable","","",66],[11,"idx","","",66],[11,"clone","","",65],[11,"clone_from","","",65],[11,"next","","",65],[11,"size_hint","","",65],[11,"size_hint","","",65],[11,"next_back","","",65],[11,"indexable","","",65],[11,"idx","","",65],[11,"clone","","",72],[11,"clone_from","","",72],[11,"next","","",72],[11,"size_hint","","",72],[11,"size_hint","","",72],[11,"next_back","","",72],[11,"clone","","",73],[11,"clone_from","","",73],[11,"next","","",73],[11,"size_hint","","",73],[11,"size_hint","","",73],[11,"next_back","","",73],[11,"clone","","",62],[11,"clone_from","","",62],[11,"next","","",62],[11,"size_hint","","",62],[11,"size_hint","","",62],[11,"next_back","","",62],[11,"indexable","","",62],[11,"idx","","",62],[11,"next","","",74],[11,"size_hint","","",74],[11,"size_hint","","",74],[11,"len","","",74],[11,"peek","","Return a reference to the next element of the iterator with out advancing it,\nor None if the iterator is exhausted.",74],[11,"is_empty","","Check whether peekable iterator is empty or not.",74],[11,"clone","","",75],[11,"clone_from","","",75],[11,"next","","",75],[11,"size_hint","","",75],[11,"size_hint","","",75],[11,"clone","","",76],[11,"clone_from","","",76],[11,"next","","",76],[11,"size_hint","","",76],[11,"size_hint","","",76],[11,"clone","","",77],[11,"clone_from","","",77],[11,"next","","",77],[11,"size_hint","","",77],[11,"size_hint","","",77],[11,"indexable","","",77],[11,"idx","","",77],[11,"len","","",77],[11,"clone","","",78],[11,"clone_from","","",78],[11,"next","","",78],[11,"size_hint","","",78],[11,"size_hint","","",78],[11,"indexable","","",78],[11,"idx","","",78],[11,"len","","",78],[11,"clone","","",79],[11,"clone_from","","",79],[11,"next","","",79],[11,"size_hint","","",79],[11,"size_hint","","",79],[11,"clone","","",80],[11,"clone_from","","",80],[11,"next","","",80],[11,"size_hint","","",80],[11,"size_hint","","",80],[11,"next_back","","",80],[11,"clone","","",81],[11,"clone_from","","",81],[11,"next","","",81],[11,"size_hint","","",81],[11,"size_hint","","",81],[11,"next_back","","",81],[11,"indexable","","",81],[11,"idx","","",81],[11,"len","","",81],[11,"reset_fuse","","Resets the fuse such that the next call to .next() or .next_back() will\ncall the underlying iterator again even if it previously returned None.",81],[11,"clone","","",63],[11,"clone_from","","",63],[11,"next","","",63],[11,"size_hint","","",63],[11,"size_hint","","",63],[11,"next_back","","",63],[11,"indexable","","",63],[11,"idx","","",63],[11,"clone","","",82],[11,"clone_from","","",82],[11,"new","","Creates a new iterator with the specified closure as the \"iterator\nfunction\" and an initial state to eventually pass to the closure",82],[11,"next","","",82],[11,"size_hint","","",82],[11,"size_hint","","",82],[11,"clone","","",83],[11,"clone_from","","",83],[11,"next","","",83],[11,"size_hint","","",83],[11,"size_hint","","",83],[11,"clone","","",84],[11,"clone_from","","",84],[11,"next","","",84],[11,"size_hint","","",84],[11,"size_hint","","",84],[11,"next_back","","",84],[11,"clone","","",85],[11,"clone_from","","",85],[11,"next","","",85],[11,"size_hint","","",85],[11,"size_hint","","",85],[11,"next_back","","",85],[11,"clone","","",86],[11,"clone_from","","",86],[11,"next","","",86],[11,"size_hint","","",86],[11,"clone","","",87],[11,"clone_from","","",87],[11,"next","","",87],[11,"size_hint","","",87],[11,"next","core::ops","",37],[11,"size_hint","","",37],[11,"size_hint","","",37],[11,"len","","",37],[11,"next","","",37],[11,"size_hint","","",37],[11,"size_hint","","",37],[11,"len","","",37],[11,"next","","",37],[11,"size_hint","","",37],[11,"size_hint","","",37],[11,"len","","",37],[11,"next","","",37],[11,"size_hint","","",37],[11,"size_hint","","",37],[11,"len","","",37],[11,"next","","",37],[11,"size_hint","","",37],[11,"size_hint","","",37],[11,"len","","",37],[11,"next","","",37],[11,"size_hint","","",37],[11,"size_hint","","",37],[11,"len","","",37],[11,"next","","",37],[11,"size_hint","","",37],[11,"size_hint","","",37],[11,"len","","",37],[11,"next","","",37],[11,"size_hint","","",37],[11,"size_hint","","",37],[11,"len","","",37],[11,"next","","",37],[11,"size_hint","","",37],[11,"size_hint","","",37],[11,"len","","",37],[11,"next","","",37],[11,"size_hint","","",37],[11,"size_hint","","",37],[11,"len","","",37],[11,"next_back","","",37],[11,"next","","",38],[11,"size_hint","","",38],[11,"next_back","","",37],[11,"next","","",38],[11,"size_hint","","",38],[11,"next_back","","",37],[11,"next","","",38],[11,"size_hint","","",38],[11,"next_back","","",37],[11,"next","","",38],[11,"size_hint","","",38],[11,"next_back","","",37],[11,"next","","",38],[11,"size_hint","","",38],[11,"next_back","","",37],[11,"next","","",38],[11,"size_hint","","",38],[11,"next_back","","",37],[11,"next","","",38],[11,"size_hint","","",38],[11,"next_back","","",37],[11,"next","","",38],[11,"size_hint","","",38],[11,"next_back","","",37],[11,"next","","",38],[11,"size_hint","","",38],[11,"next_back","","",37],[11,"next","","",38],[11,"size_hint","","",38],[11,"clone","core::iter","",88],[11,"clone_from","","",88],[11,"next","","",88],[11,"size_hint","","",88],[11,"size_hint","","",88],[11,"next_back","","",88],[11,"indexable","","",88],[11,"idx","","",88],[11,"hash","core::option","",24],[11,"fmt","","",24],[11,"cmp","","",24],[11,"assert_receiver_is_total_eq","","",24],[11,"partial_cmp","","",24],[11,"lt","","",24],[11,"le","","",24],[11,"gt","","",24],[11,"ge","","",24],[11,"lt","","",24],[11,"le","","",24],[11,"gt","","",24],[11,"ge","","",24],[11,"eq","","",24],[11,"ne","","",24],[11,"ne","","",24],[11,"clone","","",24],[11,"clone_from","","",24],[11,"as_slice","","Convert from `Option<T>` to `&[T]` (without copying)",24],[11,"default","","",24],[11,"clone","","",89],[11,"clone_from","","",89],[11,"next","","",89],[11,"size_hint","","",89],[11,"size_hint","","",89],[11,"next_back","","",89],[11,"len","","",89],[11,"next","","",90],[11,"size_hint","","",90],[11,"size_hint","","",90],[11,"next_back","","",90],[11,"len","","",90],[11,"clone","","",90],[11,"clone_from","","",90],[11,"next","","",91],[11,"size_hint","","",91],[11,"size_hint","","",91],[11,"next_back","","",91],[11,"len","","",91],[11,"next","","",92],[11,"size_hint","","",92],[11,"size_hint","","",92],[11,"next_back","","",92],[11,"len","","",92],[11,"from_iter","","Takes each element in the `Iterator`: if it is `None`, no further\nelements are taken, and the `None` is returned. Should no `None` occur, a\ncontainer with the values of each `Option` is returned.",24],[11,"hash","core::result","",93],[11,"fmt","","",93],[11,"cmp","","",93],[11,"assert_receiver_is_total_eq","","",93],[11,"partial_cmp","","",93],[11,"lt","","",93],[11,"le","","",93],[11,"gt","","",93],[11,"ge","","",93],[11,"lt","","",93],[11,"le","","",93],[11,"gt","","",93],[11,"ge","","",93],[11,"eq","","",93],[11,"ne","","",93],[11,"ne","","",93],[11,"clone","","",93],[11,"clone_from","","",93],[11,"is_ok","","Returns true if the result is `Ok`",93],[11,"is_err","","Returns true if the result is `Err`",93],[11,"ok","","Convert from `Result<T, E>` to `Option<T>`",93],[11,"err","","Convert from `Result<T, E>` to `Option<E>`",93],[11,"as_ref","","Convert from `Result<T, E>` to `Result<&T, &E>`",93],[11,"as_mut","","Convert from `Result<T, E>` to `Result<&mut T, &mut E>`",93],[11,"as_mut_slice","","Convert from `Result<T, E>` to `&mut [T]` (without copying)",93],[11,"map","","Maps a `Result<T, E>` to `Result<U, E>` by applying a function to an\ncontained `Ok` value, leaving an `Err` value untouched.",93],[11,"map_err","","Maps a `Result<T, E>` to `Result<T, F>` by applying a function to an\ncontained `Err` value, leaving an `Ok` value untouched.",93],[11,"iter","","Returns an iterator over the possibly contained value.",93],[11,"iter_mut","","Returns a mutable iterator over the possibly contained value.",93],[11,"into_iter","","Returns a consuming iterator over the possibly contained value.",93],[11,"and","","Returns `res` if the result is `Ok`, otherwise returns the `Err` value of `self`.",93],[11,"and_then","","Calls `op` if the result is `Ok`, otherwise returns the `Err` value of `self`.",93],[11,"or","","Returns `res` if the result is `Err`, otherwise returns the `Ok` value of `self`.",93],[11,"or_else","","Calls `op` if the result is `Err`, otherwise returns the `Ok` value of `self`.",93],[11,"unwrap_or","","Unwraps a result, yielding the content of an `Ok`.\nElse it returns `optb`.",93],[11,"unwrap_or_else","","Unwraps a result, yielding the content of an `Ok`.\nIf the value is an `Err` then it calls `op` with its value.",93],[11,"unwrap","","Unwraps a result, yielding the content of an `Ok`.",93],[11,"unwrap_err","","Unwraps a result, yielding the content of an `Err`.",93],[11,"as_slice","","Convert from `Result<T, E>` to `&[T]` (without copying)",93],[11,"next","","",94],[11,"size_hint","","",94],[11,"size_hint","","",94],[11,"next_back","","",94],[11,"len","","",94],[11,"clone","","",94],[11,"clone_from","","",94],[11,"next","","",95],[11,"size_hint","","",95],[11,"size_hint","","",95],[11,"next_back","","",95],[11,"len","","",95],[11,"next","","",96],[11,"size_hint","","",96],[11,"size_hint","","",96],[11,"next_back","","",96],[11,"len","","",96],[11,"from_iter","","Takes each element in the `Iterator`: if it is an `Err`, no further\nelements are taken, and the `Err` is returned. Should no `Err` occur, a\ncontainer with the values of each `Result` is returned.",93],[11,"fmt","core::simd","",97],[11,"fmt","","",98],[11,"fmt","","",99],[11,"fmt","","",100],[11,"fmt","","",101],[11,"fmt","","",102],[11,"fmt","","",103],[11,"fmt","","",104],[11,"fmt","","",105],[11,"fmt","","",106],[11,"index","core::slice","",107],[11,"index","","",107],[11,"index","","",107],[11,"index","","",107],[11,"as_slice","","View the underlying data as a subslice of the original data.",107],[11,"next","","",107],[11,"size_hint","","",107],[11,"size_hint","","",107],[11,"next_back","","",107],[11,"len","","",107],[11,"clone","","",107],[11,"clone_from","","",107],[11,"indexable","","",107],[11,"idx","","",107],[11,"index","","",108],[11,"index","","",108],[11,"index","","",108],[11,"index","","",108],[11,"index_mut","","",108],[11,"index_mut","","",108],[11,"index_mut","","",108],[11,"index_mut","","",108],[11,"into_slice","","View the underlying data as a subslice of the original data.",108],[11,"next","","",108],[11,"size_hint","","",108],[11,"size_hint","","",108],[11,"next_back","","",108],[11,"len","","",108],[11,"clone","","",109],[11,"clone_from","","",109],[11,"next","","",109],[11,"size_hint","","",109],[11,"size_hint","","",109],[11,"next_back","","",109],[11,"finish","","",109],[11,"finish","","",110],[11,"next","","",110],[11,"size_hint","","",110],[11,"size_hint","","",110],[11,"next_back","","",110],[11,"next","","",111],[11,"size_hint","","",111],[11,"size_hint","","",111],[11,"next","","",112],[11,"size_hint","","",112],[11,"size_hint","","",112],[11,"next","","",113],[11,"size_hint","","",113],[11,"size_hint","","",113],[11,"next","","",114],[11,"size_hint","","",114],[11,"size_hint","","",114],[11,"next","","",115],[11,"size_hint","","",115],[11,"size_hint","","",115],[11,"clone","","",116],[11,"clone_from","","",116],[11,"next","","",116],[11,"size_hint","","",116],[11,"size_hint","","",116],[11,"clone","","",117],[11,"clone_from","","",117],[11,"next","","",117],[11,"size_hint","","",117],[11,"size_hint","","",117],[11,"next_back","","",117],[11,"len","","",117],[11,"indexable","","",117],[11,"idx","","",117],[11,"next","","",118],[11,"size_hint","","",118],[11,"size_hint","","",118],[11,"next_back","","",118],[11,"len","","",118],[11,"fmt","core::str","",119],[11,"clone","","",119],[11,"clone_from","","",119],[11,"eq","","",119],[11,"ne","","",119],[11,"ne","","",119],[11,"assert_receiver_is_total_eq","","",119],[11,"description","","",119],[11,"cause","","",119],[11,"fmt","","",119],[11,"clone","","",120],[11,"clone_from","","",120],[11,"next","","",120],[11,"size_hint","","",120],[11,"size_hint","","",120],[11,"next_back","","",120],[11,"clone","","",121],[11,"clone_from","","",121],[11,"next","","",121],[11,"size_hint","","",121],[11,"size_hint","","",121],[11,"next_back","","",121],[11,"clone","","",122],[11,"clone_from","","",122],[11,"next","","",122],[11,"size_hint","","",122],[11,"size_hint","","",122],[11,"next_back","","",122],[11,"len","","",122],[11,"len","","",122],[11,"clone","","",123],[11,"clone_from","","",123],[11,"call","","",123],[11,"clone","","",124],[11,"clone_from","","",124],[11,"clone","","",125],[11,"clone_from","","",125],[11,"next","","",124],[11,"size_hint","","",124],[11,"next_back","","",124],[11,"next","","",125],[11,"size_hint","","",125],[11,"clone","","",126],[11,"clone_from","","",126],[11,"clone","","",127],[11,"clone_from","","",127],[11,"clone","","",128],[11,"clone_from","","",128],[11,"clone","","",129],[11,"clone_from","","",129],[11,"clone","","",130],[11,"clone_from","","",130],[11,"next","","",129],[11,"size_hint","","",129],[11,"next","","",130],[11,"size_hint","","",130],[11,"clone","","",131],[11,"clone_from","","",131],[11,"next","","",131],[11,"size_hint","","",131],[11,"size_hint","","",131],[11,"next_back","","",131],[11,"clone","","",132],[11,"clone_from","","",132],[11,"next","","",132],[11,"size_hint","","",132],[11,"size_hint","","",132],[11,"next_back","","",132],[11,"clone","","",133],[11,"clone_from","","",133],[11,"next","","",133],[11,"size_hint","","",133],[11,"size_hint","","",133],[11,"clone","","",134],[11,"clone_from","","",134],[11,"next","","",134],[11,"size_hint","","",134],[11,"size_hint","","",134],[11,"next","","",135],[11,"size_hint","","",135],[11,"size_hint","","",135],[11,"next_back","","",135],[11,"next","","",136],[11,"size_hint","","",136],[11,"size_hint","","",136],[11,"next_back","","",136],[11,"new","core::hash::sip","Creates a new `SipHasher` with the two initial keys set to 0.",137],[11,"new_with_keys","","Creates a `SipHasher` that is keyed off the provided keys.",137],[11,"result","","Returns the computed hash.",137],[11,"write","","",137],[11,"reset","","",137],[11,"finish","","",137],[11,"clone","","",137],[11,"clone_from","","",137],[11,"default","","",137],[11,"hash","core::borrow","",49],[11,"eq","core::fmt::num","",138],[11,"ne","","",138],[11,"ne","","",138],[11,"clone","","",138],[11,"clone_from","","",138],[11,"eq","","",139],[11,"ne","","",139],[11,"ne","","",139],[11,"clone","","",139],[11,"clone_from","","",139],[11,"eq","","",140],[11,"ne","","",140],[11,"ne","","",140],[11,"clone","","",140],[11,"clone_from","","",140],[11,"eq","","",141],[11,"ne","","",141],[11,"ne","","",141],[11,"clone","","",141],[11,"clone_from","","",141],[11,"eq","","",142],[11,"ne","","",142],[11,"ne","","",142],[11,"clone","","",142],[11,"clone_from","","",142],[11,"eq","","",143],[11,"ne","","",143],[11,"ne","","",143],[11,"clone","","",143],[11,"clone_from","","",143],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"fmt","","",144],[11,"eq","core::fmt::rt","",145],[11,"ne","","",145],[11,"ne","","",145],[11,"fmt","core::fmt","",146],[11,"fmt","","",147],[11,"fmt","","",147],[11,"pad_integral","","Performs the correct padding for an integer which has already been\nemitted into a byte-array. The byte-array should *not* contain the sign\nfor the integer, that will be added by this method.",148],[11,"pad","","This function takes a string slice and emits it to the internal buffer\nafter applying the relevant formatting flags specified. The flags\nrecognized for generic strings are:",148],[11,"write_str","","Writes some data to the underlying buffer contained within this\nformatter.",148],[11,"write_fmt","","Writes some formatted information into this instance",148],[11,"flags","","Flags for formatting (packed version of rt::Flag)",148],[11,"fill","","Character used as 'fill' whenever there is alignment",148],[11,"align","","Flag indicating what form of alignment was requested",148],[11,"width","","Optionally specified integer width that the output should be",148],[11,"precision","","Optionally specified precision for numeric types",148],[11,"fmt","","",146],[11,"fmt","core::cell","",50],[11,"fmt","","",51],[11,"fmt","","",53],[11,"fmt","","",55],[8,"Rand","rand","A type that can be randomly generated using an `Rng`."],[10,"rand","","Generates a random instance of this type using the specified source of\nrandomness.",149],[8,"Rng","","A random number generator."],[10,"next_u32","","Return the next random u32.",150],[11,"next_u64","","Return the next random u64.",150],[11,"next_f32","","Return the next random f32 selected from the half-open\ninterval `[0, 1)`.",150],[11,"next_f64","","Return the next random f64 selected from the half-open\ninterval `[0, 1)`.",150],[11,"fill_bytes","","Fill `dest` with random data.",150],[11,"gen","","Return a random value of a `Rand` type.",150],[11,"gen_iter","","Return an iterator that will yield an infinite number of randomly\ngenerated items.",150],[11,"gen_range","","Generate a random value in the range [`low`, `high`).",150],[11,"gen_weighted_bool","","Return a bool with a 1 in n chance of true",150],[11,"gen_ascii_chars","","Return an iterator of random characters from the set A-Z,a-z,0-9.",150],[11,"choose","","Return a random element from `values`.",150],[11,"shuffle","","Shuffle a mutable slice in place.",150],[8,"SeedableRng","","A random number generator that can be explicitly seeded to produce\nthe same stream of randomness multiple times."],[10,"reseed","","Reseed an RNG with the given seed.",151],[10,"from_seed","","Create a new RNG with the given seed.",151],[6,"Item","",""],[11,"next","","",152],[6,"Item","",""],[11,"next","","",153],[11,"clone","","",154],[11,"new_unseeded","","Creates a new XorShiftRng instance which is not seeded.",154],[11,"next_u32","","",154],[11,"reseed","","Reseed an XorShiftRng. This will panic if `seed` is entirely 0.",154],[11,"from_seed","","Create a new XorShiftRng. This will panic if `seed` is entirely 0.",154],[11,"rand","","",154]],"paths":[[3,"Weighted"],[8,"SampleRange"],[3,"Range"],[3,"Gamma"],[3,"ChiSquared"],[3,"FisherF"],[3,"StudentT"],[3,"StandardNormal"],[3,"Normal"],[3,"LogNormal"],[3,"Exp1"],[3,"Exp"],[8,"Sample"],[8,"IndependentSample"],[3,"RandSample"],[3,"WeightedChoice"],[3,"IsaacRng"],[3,"Isaac64Rng"],[3,"ChaChaRng"],[3,"ReseedingRng"],[8,"Reseeder"],[3,"ReseedWithDefault"],[3,"Open01"],[3,"Closed01"],[4,"Option"],[4,"FpCategory"],[3,"NonZero"],[3,"Unique"],[3,"CovariantType"],[3,"ContravariantType"],[3,"InvariantType"],[3,"CovariantLifetime"],[3,"ContravariantLifetime"],[3,"InvariantLifetime"],[3,"NoCopy"],[3,"Managed"],[3,"RangeFull"],[3,"Range"],[3,"RangeFrom"],[3,"RangeTo"],[4,"Ordering"],[8,"Any"],[3,"TypeId"],[3,"AtomicBool"],[3,"AtomicIsize"],[3,"AtomicUsize"],[3,"AtomicPtr"],[3,"AtomicInt"],[3,"AtomicUint"],[4,"Cow"],[3,"Cell"],[3,"RefCell"],[3,"BorrowRef"],[3,"Ref"],[3,"BorrowRefMut"],[3,"RefMut"],[3,"UnsafeCell"],[3,"EscapeUnicode"],[4,"EscapeUnicodeState"],[3,"EscapeDefault"],[4,"EscapeDefaultState"],[3,"Finallyalizer"],[3,"Enumerate"],[3,"Inspect"],[3,"Rev"],[3,"Map"],[3,"Zip"],[3,"ByRef"],[4,"MinMaxResult"],[3,"Cloned"],[3,"Cycle"],[3,"Chain"],[3,"Filter"],[3,"FilterMap"],[3,"Peekable"],[3,"SkipWhile"],[3,"TakeWhile"],[3,"Skip"],[3,"Take"],[3,"Scan"],[3,"FlatMap"],[3,"Fuse"],[3,"Unfold"],[3,"Counter"],[3,"Range"],[3,"RangeInclusive"],[3,"RangeStep"],[3,"RangeStepInclusive"],[3,"Repeat"],[3,"Item"],[3,"Iter"],[3,"IterMut"],[3,"IntoIter"],[4,"Result"],[3,"Iter"],[3,"IterMut"],[3,"IntoIter"],[3,"i8x16"],[3,"i16x8"],[3,"i32x4"],[3,"i64x2"],[3,"u8x16"],[3,"u16x8"],[3,"u32x4"],[3,"u64x2"],[3,"f32x4"],[3,"f64x2"],[3,"Iter"],[3,"IterMut"],[3,"Split"],[3,"SplitMut"],[3,"GenericSplitN"],[3,"SplitN"],[3,"RSplitN"],[3,"SplitNMut"],[3,"RSplitNMut"],[3,"Windows"],[3,"Chunks"],[3,"ChunksMut"],[4,"Utf8Error"],[3,"Chars"],[3,"CharIndices"],[3,"Bytes"],[3,"BytesDeref"],[3,"CharSplits"],[3,"CharSplitsN"],[3,"NaiveSearcher"],[3,"TwoWaySearcher"],[4,"Searcher"],[3,"MatchIndices"],[3,"SplitStr"],[3,"Split"],[3,"SplitTerminator"],[3,"SplitN"],[3,"RSplitN"],[3,"Lines"],[3,"LinesAny"],[3,"SipHasher"],[3,"Binary"],[3,"Octal"],[3,"Decimal"],[3,"LowerHex"],[3,"UpperHex"],[3,"Radix"],[3,"RadixFmt"],[4,"Alignment"],[3,"Error"],[3,"Arguments"],[3,"Formatter"],[8,"Rand"],[8,"Rng"],[8,"SeedableRng"],[3,"Generator"],[3,"AsciiGenerator"],[3,"XorShiftRng"]]};
initSearch(searchIndex);
